$(function() {
  var container_dimensions = {width: 700, height: 467},
      margins = {top: 20, right: 22, bottom: 20, left: 18},
      level_dimensions = {
        width: container_dimensions.width - margins.left - margins.right,
        height: container_dimensions.height - margins.top - margins.bottom
      },
      grid,
      gridRows = 12,
      gridColumns = 18,
      goalReached = false,
      transitionDuration = 300,
      cellWidth = level_dimensions.width / gridColumns,
      cellHeight = level_dimensions.height / gridRows,
      walls = [],
      roverPos = {x: 0, y: 0, rotation: 0, cruise_on: false},
      roverData = [{x: 0, y: 0}],
      goal = {x: gridColumns - 1, y: gridRows - 1},
      goalData = [goal],
      x = d3.scale.linear().range([0, level_dimensions.width]),
      y = d3.scale.linear().range([0, level_dimensions.height]),
      offsetX = function(d) {
        return x(d.x) - cellWidth / 2;
      },
      offsetY = function(d) {
        return y(d.y) - cellHeight / 2;
      },
      roverOffsetX = function(d) {
        return x(d.x) - (cellWidth / 4);
      },
      roverOffsetY = function(d) {
        return y(d.y) - (cellHeight / 4);
      },

      line = d3.svg.line()
        .x(function(d) { return x(d.x); })
        .y(function(d) { return y(d.y); }),

      debug = function(text) {
        $("#debug").append("<p> " + text + "</p>");
      },

      svg = d3.select("#level-content")
        .append("svg")
        .attr("height", container_dimensions.height)
        .attr("width", container_dimensions.width)
        .append("g")
        .attr("transform", "translate(" + margins.left + "," + margins.top + ")"),

      buildWalls = function() {
        var i, j, y=0, minY=1, maxY, wall, numWalls;
        numWalls = Math.ceil(Math.random() * 4) * 2;
        numWalls = d3.min([numWalls, Math.floor((gridRows - 1) / 2)]);
        debug("num walls: " + numWalls);
        walls = [];

        for(i=0; i<numWalls; i++) {
          wall = new Array();
          maxY = gridRows - 1 - ((numWalls - i - 1) * 2)
          y = Math.floor(Math.random() * (maxY - minY)) + minY;
          // $("#debug").append("<p> y: " + y + "</p>");
          if (i % 2 === 0) {
            // Left wall
            for(j=0; j<gridColumns-2; j++) {
              wall.push({x: j, y: y});
            }
          } else {
            // Right wall
            for(j=2; j<gridColumns; j++) {
              wall.push({x: j, y: y});
            }
          }
          walls.push(wall);
          minY = y + 2;
        }
      },

      populateGrid = function() {
        var i, j, wall, wallPoint;

        grid = new Array(gridRows);
        for(i=0; i<gridRows; i++) {
          grid[i] = [];
          for(j=0; j<gridColumns; j++) {
            grid[i].push(0);
          }
        }

        for(i=0; i<walls.length; i++) {
          wall = walls[i];
          for(j=0; j<wall.length; j++) {
            wallPoint = wall[j];
            grid[wallPoint.y][wallPoint.x] = 1;
          }
        }
      },

      animatedRender = function() {
        d3.transition()
          .duration(transitionDuration)
          .ease('linear')
          .each(render);
      },

      render = function() {
        var wallSelection = svg.selectAll(".wall").data(walls);
        wallSelection.enter()
          .append("g")
          .attr("class", "wall");

        wallSelection.exit().remove();

        var wallBlocks = wallSelection.selectAll(".block")
          .data(function(d) { return d; });

        wallBlocks.enter()
          .append("rect")
          .attr("class", "block")
          .attr("x", offsetX)
          .attr("y", offsetY)
          .attr("rx", "1")
          .attr("ry", "1")
          .attr("height", cellHeight)
          .attr("width", cellWidth);

        wallBlocks.transition()
          .attr("x", offsetX)
          .attr("y", offsetY);

        //svg.selectAll(".gridLine")
        //  .data(
        //    [
        //        [{x: 0, y: 0}, {x: gridColumns - 1, y: 0}],
        //        [{x: 0, y: 0}, {x: 0, y: gridRows - 1}],
        //        [{x: gridColumns - 1, y: 0}, {x: gridColumns - 1, y: gridRows - 1}],
        //        [{x: 0, y: gridRows - 1}, {x: gridColumns - 1, y: gridRows - 1}],
        //    ]
        //  )
        //  .enter()
        //  .append("path")
        //  .attr("class", "wall")
        //  .attr("d", line);

        var roverSelection = svg.selectAll(".rover").data(roverData);
        var roverEnter = roverSelection.enter()
          .append("rect")
          .attr("class", "rover")
          .attr("x",function(d) { roverOffsetX; })
          .attr("y",function(d) { roverOffsetY; })
          .attr("width", cellWidth / 4)
          .attr("height", cellHeight / 4);
          //.attr("rx", "1");
          //.attr("cy", function(d) { return y(d.y); });

        roverSelection.attr("transform", "translate(" + x(roverPos.x) + "," + y(roverPos.y) + ")");

        var goalSelection = svg.selectAll(".goal").data(goalData);
        goalSelection.enter()
          .append("circle")
          .attr("class", "goal")
          .attr("r", cellWidth / 4)
          .attr("cx", function(d) { return x(d.x); })
          .attr("cy", function(d) { return y(d.y); });

      },

      outOfBounds = function(position) {
        if (position.x < 0 || position.y < 0) return true;
        if (position.x > gridColumns - 1 || position.y > gridRows - 1) return true;
        return false;
      },

      collision = function(position) {
        if (grid[position.y][position.x] === 1) return true;
        return false;
      },

      reachedGoal = function(position) {
        if (position.x === goal.x && position.y === goal.y) return true;
        return false;
      },

      endLevel = function() {
        goalReached = true;
        $("#goal-reached").modal('show');
      },

      moveRover = function(coordinate, direction) {
        if (reachedGoal(roverPos)) {
          endLevel();
        }

        if (!roverPos.cruise_on) return;

        var newPosition = {x: roverPos.x, y: roverPos.y};

        if (roverPos.rotation === 0) {
          newPosition.x += 1;
        } else if (roverPos.rotation === 90) {
          newPosition.y -= 1;
        } else if (roverPos.rotation === 180) {
          newPosition.x -= 1;
        } else if (roverPos.rotation === 270) {
          newPosition.y += 1;
        }

        if (outOfBounds(newPosition) || collision(newPosition)) return;

        roverPos.x = newPosition.x;
        roverPos.y = newPosition.y;

        svg.selectAll(".rover").transition()
          .duration(transitionDuration)
          .ease('linear')
          .attr("transform", "translate(" + x(roverPos.x) + "," + y(roverPos.y) + ")");
      },

      updateScene = function() {
        moveRover();
        if (!goalReached) {
          setTimeout(function() { updateScene(); }, transitionDuration);
        }
      },

      generate = function() {
        // Todo: Rover needs to be a class that can re-initialize itself
        roverPos.x = 0;
        roverPos.y = 0;
        roverPos.cruise_on = false;
        roverPos.rotation = 0;
        buildWalls();
        populateGrid();
        animatedRender();
      };

    $("#generate").click(function() {
      generate();
    });

    $(".move").click(function() {
      var action = $(this).attr("data-action");
      if (action.indexOf("on") > -1) {
        roverPos.cruise_on = true;
      } else {
        roverPos.cruise_on = false;
      }
    });

    $(".rotate").click(function() {
      roverPos.rotation -= 90;
      if (roverPos.rotation < 0) roverPos.rotation = 270;
    });

    x.domain([0, gridColumns - 1]);
    y.domain([0, gridRows - 1]);

    generate();

    setTimeout(function() { updateScene() }, transitionDuration);
});
